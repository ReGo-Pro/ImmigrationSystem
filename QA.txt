======================================================================================================================================================================
Q.	When submitting a DTO to SignUp endpoint, is it safe to send password in plain text over HTTPS? If not, what other options are available?
A.	From Microsoft Copilot
	It is standard practice to send passwords over HTTPS in plain text. 
	Ensure that you send the password via a POST request, not a GET request. GET requests could expose the password in browser history logs or web server access logs.
	Some login forms use JavaScript to hash the password before sending it. However, this approach doesn’t significantly enhance security.
	Other considerations:
		-	Consider setting an authenticated cookie after successful authentication.
		-	Another option is using HTTP Digest Authorization over HTTPS.
		-	HTTP Basic Auth: While not ideal, HTTP Basic Auth over HTTPS is still more secure than sending credentials in the URL
======================================================================================================================================================================
Q.	How to deal with model validation (DTO) in ASP.NET Core MVC?
A.	From Microsoft Copilot and my own tests
	A good way is to use DataAnnotation attributes for simple validations. For complex validation, one of the following options can be used:
		-	Custom Validation Attributes
		-	FluentValidation: FluentValidation is a powerful library that provides expressive validation rules
		-	Service Layer Validation: Implement custom validation logic in your service layer.
		-	Middleware for Validation: Create a custom middleware that intercepts requests before reaching the controller.
		-	Domain-Driven Design (DDD) Validators: If you follow DDD principles, consider placing validation logic within your domain entities or value objects
	* The first thing I'll test in this project is "Service Layer Validation"
======================================================================================================================================================================
Q.	Is it OK to use a single UnitOfWork service for my entire application?
A.	Yes and No! 
	If the application is fairly small, all of the required service interfaces can be defined inside a UnitOfWork Interface and it can be passed throughout the app. 
	Since ASP.NET Core's DI container handles service instanciation in a lazy fashion (for scoped services), the services that are not explicitly requested will not
	be instanciated, so no worries there. However the UnitOfWork can grow and become very large and hard to manage as the application grows.
	So maybe it's a good idea to have multiple UnitOfWork interfaces for different scopes of the application (something like bounded context in DDD).
	* Also when using a single repository for entire application it is absolutely essential to make sure to use lazy instanciation for repositories.
======================================================================================================================================================================
Q.	Comparing having SaveChanges in repo vs single unit of work vs unit of work per controller. 
A.	From my own research and testing and thinking
	When you use SaveChanges in a single repo, handling transactions is a challange, take Client and ClientLogin in SignUp endpoint in this API for example. If I save
	changes in Client repo and then in ClientLogin repo, I have to find a way to revert Client creation if ClientLogin fails. But when we use a unit of work, handling
	transaction is very easy. You just make all your changes on DbContext and add SaveChanges once which is transactional it an on itself. Also less roundtrip to
	database. 
	Using a single unit of work is not very efficient because for each request you end up instanciating many repositories that are not required to handle that request.
	But when you use a unit of work for each controller, you have a much better control over transactions and you only instanciate repositories that are used in that
	controller which is much more efficient. If a controller does not deal with multiple entities at the same time, you do not need a unit of work and you can just add
	SaveChanges to the repository itself. But it might be a good idea to be consistent.
======================================================================================================================================================================
Q.	What is the default transactional behavior of DbContext in EF Core?
A.	By default, when you call SaveChanges (or SaveChangesAsync) on the DbContext, it wraps all changes (from all DbSet instances) in a single transaction. If any part 
	of the transaction fails (e.g., an exception is thrown), all changes are rolled back. This ensures that the database remains in a consistent state.
	You can also use explicit tranactions using Database.BeginTransaction method. In this case, you create a transaction explicitly, and you have more control over how 
	changes are committed or rolled back. If you handle multiple DbSet instances within the same transaction, a failure in one set won’t affect the others until you 
	explicitly commit or roll back the transaction.
======================================================================================================================================================================
Q.	What are 3 different service scopes in ASP.NET DI and what does each one mean? (just to refresh my memory)
A.	Singleton: an instance of the service is created once and the same instance is used throughout the application until the application is shut down.
	Scoped: an instance of the service is created for each request which stays alive while the request is in porgress.
	Transient: everytime a new instance of the service is required, a fresh one is created. This means that even within the same request we never use the same instance.
======================================================================================================================================================================
Q.	Why am I getting exception when trying to access association properties on entities (example: ClientLogin from Clien)
	The reason is that by default lazy loading is not enabled in EF Core. In order to enable it, you have to follow the following steps:
	-	install the required package: Microsoft.EntityFrameworkCore.Proxies
	-	Enable lazy loading by using UseLazyLoadingProxies() when registering DbContext in DI. (see the code)
======================================================================================================================================================================
Q.	Why is the compiler complaining about the following code (ToListAsync is not defined):
	public async Task<List<TEntity>> GetAllAsync(Func<TEntity, bool> predicate) {
		return await _dbContext.Set<TEntity>().Where(predicate).ToListAsync();
	}
A.	The reason is that when we want to deal with generic DbContext and its sets, all filtering inputs must be of type Expression and not Func. So we should rewrite the
	code like this:
	public async Task<List<TEntity>> GetAllAsync(Expression<Func<TEntity, bool>> predicate)
	Now the compiler does not complain. The reason is that when you pass an expression, compiler treats Where clause as being applied to IQueriable, but when you pass 
	Func directly, the compiler thinks Where is applied to an IEnumerable which indeed does not contain ToLystAsync. 
	* So when dealing with custom methods on DbContext, always use Expression<Func> as input
======================================================================================================================================================================